// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// MLB Utility Library Module File
// ////////////////////////////////////////////////////////////////////////////
/*
   File Name         :  TimeSpec.cpp

   File Description  :  Implementation of the TimeSpec class.

   Revision History  :  1994-05-21 --- Added to C genfuncs lib as timespec.c
                           Michael L. Brock
                        1998-04-08 --- Revision for the MlbDev Utility library.
                           Michael L. Brock
                        2022-10-01 --- Added to MlbDev3 Utility library.
                           Michael L. Brock

      Copyright Michael L. Brock 1998 - 2023.
      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      http://www.boost.org/LICENSE_1_0.txt)

*/
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// Required include files...
// ////////////////////////////////////////////////////////////////////////////

#include <Utility/TimeSpec.hpp>

#include <Utility/AnyToString.hpp>
#include <Utility/ExceptionRethrow.hpp>
#include <Utility/nstrcpy.hpp>

#include <limits>

// ////////////////////////////////////////////////////////////////////////////

// Note: TimeSpec::AddSeconds() is implemented in TimeSupport.cpp.

namespace MLB {

namespace Utility {

namespace {

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//	Used to get high-granularity times under Windows...
// ////////////////////////////////////////////////////////////////////////////
#ifdef _Windows
typedef union {
	FILETIME         struct_data;
	unsigned __int64 scalar_data;
} WIN32_FILETIME_64;
# ifdef __MINGW32__
#  define WIN32_FILETIME_EPOCH_BIAS	116444736000000000LL
# else
#  define WIN32_FILETIME_EPOCH_BIAS	116444736000000000i64
# endif // # ifdef __MINGW32__
#endif // #ifdef _Windows
// ////////////////////////////////////////////////////////////////////////////

} // Anonymous namespace

// ////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec()
{
	*this = TimeSpec::Now();
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec(time_t in_secs, long in_nsecs)
{
	tv_sec  = static_cast<long>(in_secs);
	tv_nsec = in_nsecs;
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec(const timespec &in_time)
	:timespec(in_time)
{
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec(const timeval &in_time)
{
	tv_sec  = in_time.tv_sec;
	tv_nsec = in_time.tv_usec * 1000;
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec(const std::string &in_date)
	:timespec(FromString(in_date))
{
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec::~TimeSpec()
{
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::SetToNow()
{
	Now().swap(*this);

	return(*this);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::SetToMinimumValue()
{
	tv_sec  = 0;
	tv_nsec = 0;

	return(*this);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::SetToMaximumValue()
{
	tv_sec  = std::numeric_limits<long>::max();
	tv_nsec = 999999999;

	return(*this);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
bool TimeSpec::IsZero() const
{
	return((tv_sec == 0) && (tv_nsec == 0));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::AddMilliseconds(int msecs_to_add)
{
	int secs_to_add = msecs_to_add / 1000;
	int new_nsec    = tv_nsec + ((msecs_to_add % 1000) * 1000000);

	if (new_nsec >= 1000000000) {
		secs_to_add += new_nsec / 1000000000;
		new_nsec    %= 1000000000;
	}
	else if (new_nsec < 0) {
		secs_to_add += -1 + (new_nsec / 1000000000);
		new_nsec     = 1000000000 + (new_nsec % 1000000000);
	}

	if (secs_to_add) {
		try {
			AddSeconds(secs_to_add);
		}
		catch (const std::exception &except) {
			Rethrow(except, "Unable to add the requested number of milliseconds "
				"(" + AnyToString(msecs_to_add) + "): " +
				std::string(except.what()));
		}
	}

	tv_nsec = new_nsec;

	return(*this);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::AddMicroseconds(int usecs_to_add)
{
	int secs_to_add = usecs_to_add / 1000000;
	int new_nsec    = tv_nsec + ((usecs_to_add % 1000000) * 1000);

	if (new_nsec >= 1000000000) {
		secs_to_add += new_nsec / 1000000000;
		new_nsec    %= 1000000000;
	}
	else if (new_nsec < 0) {
		secs_to_add += -1 + (new_nsec / 1000000000);
		new_nsec     = 1000000000 + (new_nsec % 1000000000);
	}

	if (secs_to_add) {
		try {
			AddSeconds(secs_to_add);
		}
		catch (const std::exception &except) {
			Rethrow(except, "Unable to add the requested number of microseconds "
				"(" + AnyToString(usecs_to_add) + "): " +
				std::string(except.what()));
		}
	}

	tv_nsec = new_nsec;

	return(*this);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::AddNanoseconds(int nsecs_to_add)
{
	int secs_to_add = nsecs_to_add / 1000000000;
	int new_nsec    = tv_nsec + (nsecs_to_add % 1000000000);

	if (new_nsec >= 1000000000) {
		secs_to_add += new_nsec / 1000000000;
		new_nsec    %= 1000000000;
	}
	else if (new_nsec < 0) {
		secs_to_add += -1 + (new_nsec / 1000000000);
		new_nsec     = 1000000000 + (new_nsec % 1000000000);
	}

	if (secs_to_add) {
		try {
			AddSeconds(secs_to_add);
		}
		catch (const std::exception &except) {
			Rethrow(except, "Unable to add the requested number of nanoseconds "
				"(" + AnyToString(nsecs_to_add) + "): " +
				std::string(except.what()));
		}
	}

	tv_nsec = new_nsec;

	return(*this);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void TimeSpec::swap(TimeSpec &other)
{
	std::swap(tv_sec, other.tv_sec);
	std::swap(tv_nsec, other.tv_nsec);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
char *TimeSpec::ToString(char *buffer, std::size_t max_length) const
{
	return(FormatString(TimeTM::TimeUTC(tv_sec), buffer, max_length));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string TimeSpec::ToString(std::size_t max_length) const
{
	char buffer[Length_TimeSpec + 1];

	return(ToString(buffer, max_length));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string &TimeSpec::ToString(std::string &out_string,
	std::size_t max_length) const
{
	char buffer[Length_TimeSpec + 1];

	return(out_string.assign(ToString(buffer, max_length)));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
char *TimeSpec::ToStringLocal(char *buffer, std::size_t max_length) const
{
	return(FormatString(TimeTM::TimeLocal(tv_sec), buffer, max_length));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string TimeSpec::ToStringLocal(std::size_t max_length) const
{
	char buffer[Length_TimeSpec + 1];

	return(ToStringLocal(buffer, max_length));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string &TimeSpec::ToStringLocal(std::string &out_string,
	std::size_t max_length) const
{
	char buffer[Length_TimeSpec + 1];

	return(out_string.assign(ToStringLocal(buffer, max_length)));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
char *TimeSpec::ToStringInterval(char *buffer, std::size_t max_length) const
{
	return(FormatStringInterval(buffer, max_length));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string TimeSpec::ToStringInterval(std::size_t max_length) const
{
	char buffer[LengthInterval_TimeSpec + 1];

	return(ToStringInterval(buffer, max_length));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string &TimeSpec::ToStringInterval(std::string &out_string,
	std::size_t max_length) const
{
	char buffer[LengthInterval_TimeSpec + 1];

	return(out_string.assign(ToStringInterval(buffer, max_length)));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeT TimeSpec::ToTimeT() const
{
	return(TimeT(tv_sec));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeVal TimeSpec::ToTimeVal() const
{
	return(TimeVal(tv_sec, tv_nsec / 1000));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
unsigned long long TimeSpec::ToTicks() const
{
	return(ToNanoseconds());
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
unsigned long long TimeSpec::ToSeconds() const
{
	return(static_cast<unsigned long long>(tv_sec));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
unsigned long long TimeSpec::ToMilliseconds() const
{
	return(ToNanoseconds() / 1000000ULL);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
unsigned long long TimeSpec::ToMicroseconds() const
{
	return(ToNanoseconds() / 1000ULL);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
unsigned long long TimeSpec::ToNanoseconds() const
{
	return((static_cast<unsigned long long>(tv_sec) *
		static_cast<unsigned long long>(1000000000)) +
		static_cast<unsigned long long>(tv_nsec));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDouble() const
{
	return(GetDoubleEquivalent());
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDoubleEquivalent() const
{
	return(static_cast<double>(tv_sec) +
		(static_cast<double>(tv_nsec) / 1000000000.0));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDoubleTicks() const
{
	return((static_cast<double>(tv_sec) * 1000000000.0) +
		static_cast<double>(tv_nsec));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
signed long long TimeSpec::GetDifferenceTicks(const TimeSpec &other) const
{
	return(GetDifferenceTicks(*this, other));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDifferenceTicksDouble(const TimeSpec &other) const
{
	return(GetDifferenceTicksDouble(*this, other));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDifferenceDouble(const TimeSpec &other) const
{
	return(GetDifferenceDouble(*this, other));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetDifference(const TimeSpec &other) const
{
	return(GetDifference(*this, other));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetDifferenceAbs(const TimeSpec &other) const
{
	return(GetDifferenceAbs(*this, other));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
signed long long TimeSpec::GetDifferenceTicks(const TimeSpec &lhs,
	const TimeSpec &rhs)
{
	return(static_cast<signed long long>(lhs.ToNanoseconds()) -
		static_cast<signed long long>(rhs.ToNanoseconds()));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDifferenceTicksDouble(const TimeSpec &lhs,
	const TimeSpec &rhs)
{
	return(lhs.GetDoubleTicks() - rhs.GetDoubleTicks());
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDifferenceDouble(const TimeSpec &lhs, const TimeSpec &rhs)
{
	return(lhs.GetDoubleEquivalent() - rhs.GetDoubleEquivalent());
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetDifference(const TimeSpec &lhs, const TimeSpec &rhs)
{
	signed long long tmp_value = GetDifferenceTicks(lhs, rhs);

	return(TimeSpec(static_cast<long>(tmp_value / 1000000000LL),
		static_cast<long>(tmp_value % 1000000000LL)));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetDifferenceAbs(const TimeSpec &lhs, const TimeSpec &rhs)
{
	return((lhs >= rhs) ? GetDifference(lhs, rhs) :
		GetDifference(rhs, lhs));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::FromString(const char *in_date)
{
	TimeSpec out_date(0, 0);

	ParseFromString(in_date, out_date.tv_sec, out_date.tv_nsec, 9);

	return(out_date);	
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::FromString(const std::string &in_date)
{
	return(TimeSpec::FromString(in_date.c_str()));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::FromSeconds(unsigned long long secs)
{
	return(TimeSpec(static_cast<time_t>(secs)));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::FromMilliseconds(unsigned long long msecs)
{
	return(TimeSpec(static_cast<time_t>(msecs / 1000ULL),
		static_cast<long>((msecs % 1000ULL) * 1000000ULL)));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::FromMicroseconds(unsigned long long usecs)
{
	return(TimeSpec(static_cast<time_t>(usecs / 1000000ULL),
		static_cast<long>((usecs % 1000000ULL) * 1000ULL)));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::FromNanoseconds(unsigned long long nsecs)
{
	return(TimeSpec(static_cast<time_t>(nsecs /
		static_cast<unsigned long long>(1000000000)),
		static_cast<long>(nsecs % static_cast<unsigned long long>(1000000000))));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::Now()
{
	struct timespec out_time;

#ifdef __MSDOS__
	struct timeb struct_timeb;

	ftime(&struct_timeb);
	out_time.tv_sec  = struct_timeb.time;
	out_time.tv_nsec = ((long) struct_timeb.millitm) * 1000000L;
#elif _Windows
# ifdef __MINGW32__
	WIN32_FILETIME_64 sys_time;

	GetSystemTimeAsFileTime(&sys_time.struct_data);

	out_time.tv_sec  = ((long) ((sys_time.scalar_data -
		WIN32_FILETIME_EPOCH_BIAS) / 10000000LL));
	out_time.tv_nsec = ((long) ((sys_time.scalar_data * 100LL) %
		1000000000LL));
# else
	WIN32_FILETIME_64 sys_time;

	GetSystemTimeAsFileTime(&sys_time.struct_data);

	out_time.tv_sec  = ((long) ((sys_time.scalar_data -
		WIN32_FILETIME_EPOCH_BIAS) / 10000000i64));
	out_time.tv_nsec = ((long) ((sys_time.scalar_data * 100i64) %
		1000000000i64));
# endif // # ifdef __MINGW32__
#elif _POSIX_TIMERS
	clock_gettime(CLOCK_REALTIME, &out_time);
#else
	TimeVal tmp_timeval;

	::gettimeofday(&tmp_timeval, NULL);

	out_time.tv_sec  = tmp_timeval.tv_sec;
	out_time.tv_nsec = tmp_timeval.tv_usec * 1000L;
#endif // #ifdef __MSDOS__

	return(TimeSpec(out_time));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetMinimumValue()
{
	TimeSpec tmp_datum(0, 0);

	return(tmp_datum.SetToMinimumValue());
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetMaximumValue()
{
	TimeSpec tmp_datum(0, 0);

	return(tmp_datum.SetToMaximumValue());
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
char *TimeSpec::FormatString(const TimeTM &in_tm, char *buffer,
	std::size_t max_length) const
{
	if (max_length < Length_TimeSpec) {
		char tmp_buffer[Length_TimeSpec + 1];
		return(nstrcpy(buffer, FormatString(in_tm, tmp_buffer), max_length));
	}

	//	This gets YYYY-MM-DD hh:mm:ss
	in_tm.ToString(buffer);

	return(AppendFractionalPortion(Length_TimeT, buffer));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
char *TimeSpec::FormatStringInterval(char *buffer,
	std::size_t max_length) const
{
	if (max_length < LengthInterval_TimeSpec) {
		char tmp_buffer[LengthInterval_TimeSpec + 1];
		return(nstrcpy(buffer, FormatStringInterval(tmp_buffer), max_length));
	}

	//	This gets dddddd hh:mm:ss
	TimeT tmp_time_t(tv_sec);
	tmp_time_t.ToStringInterval(buffer);

	return(AppendFractionalPortion(LengthInterval_TimeT, buffer));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
char *TimeSpec::AppendFractionalPortion(std::size_t idx, char *buffer) const
{
	//	Sanity insurance
	unsigned long nsecs =
		static_cast<unsigned long>(this->tv_nsec) % 1000000000L;

	//	Now append the period followed by the number of nanoseconds
	buffer[idx++] = '.';
	buffer[idx++] = ((char) ('0' + ((char)  (nsecs /  100000000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 100000000L) / 10000000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 10000000L) / 1000000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 1000000L) / 100000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 100000L) / 10000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 10000L) / 1000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 1000L) / 100L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 100L) / 10L))));
	buffer[idx++] = ((char) ('0' + ((char)  (nsecs %  10L))));
	buffer[idx++] = '\0';

	return(buffer);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::ostream & operator << (std::ostream &o_str, const TimeSpec &datum)
{
	char tmp_buffer[Length_TimeSpec + 1];

	o_str <<
		datum.ToString(tmp_buffer, sizeof(tmp_buffer) - 1);

	return(o_str);
}
// ////////////////////////////////////////////////////////////////////////////

} // namespace Utility

} // namespace MLB

#ifdef TEST_MAIN

#include <Utility/EmitterSep.hpp>

#include <cstdint>
#include <iomanip>
#include <iostream>

namespace {

// ////////////////////////////////////////////////////////////////////////////
std::string ShowMembers(const timespec &src)
{
   std::string dst("{ " + std::to_string(src.tv_sec) + ", " +
      std::to_string(src.tv_nsec) + "}");

   return(dst);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
template <typename DatumType>
   std::string GetRelOpText(const std::pair<DatumType, DatumType> &values,
      const char *rel_op)
{
   std::string dst("(" + ShowMembers(values.first) + " " +
      std::string(rel_op + 9, 2) + " " + ShowMembers(values.second) + ")");

   return(dst);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
#define MLB_TIMESPEC_TEST_RelOpsOne(type_name, vals, rel_op)   				\
   {                    																	\
      std::cout                     													\
         << std::left << std::setw(22) << #type_name << std::right << ": " \
         << GetRelOpText(vals, #rel_op) << " = "            					\
         << std::boolalpha << rel_op   << std::noboolalpha << '\n';        \
   }
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
#define MLB_TIMESPEC_TEST_RelOpsAll(type_name, value_a, value_b)  			\
	{  																							\
		std::pair<type_name, type_name> vals(value_a, value_b);  				\
		std::cout << MLB::Utility::EmitterSep('=');  								\
		MLB_TIMESPEC_TEST_RelOpsOne(type_name, vals, (value_a <  value_b))	\
		MLB_TIMESPEC_TEST_RelOpsOne(type_name, vals, (value_a <= value_b))	\
		MLB_TIMESPEC_TEST_RelOpsOne(type_name, vals, (value_a >  value_b))	\
		MLB_TIMESPEC_TEST_RelOpsOne(type_name, vals, (value_a >= value_b))	\
		MLB_TIMESPEC_TEST_RelOpsOne(type_name, vals, (value_a == value_b))	\
		MLB_TIMESPEC_TEST_RelOpsOne(type_name, vals, (value_a != value_b))	\
		std::cout << MLB::Utility::EmitterSep('=') << '\n';						\
	}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
#define MLB_TIMESPEC_TEST_Values(type_name)  										\
	{  																							\
		for (uint32_t idx_a_1 = 1; idx_a_1 <= 2; ++idx_a_1) { 					\
			for (long idx_a_2= 1; idx_a_2 <= 2; ++idx_a_2) {  						\
				for (uint32_t idx_b_1 = 1; idx_b_1 <= 2; ++idx_b_1) { 			\
					for (long idx_b_2 = 1; idx_b_2 <= 2; ++idx_b_2) { 				\
						type_name value_a = type_name { idx_a_1, idx_a_2 };		\
						type_name value_b = type_name { idx_b_1, idx_b_2 };		\
						MLB_TIMESPEC_TEST_RelOpsAll(type_name, value_a, value_b)	\
					}  																			\
				}  																				\
			}  																					\
		}  																						\
	}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void TEST_RunRelOpTests()
{
   MLB_TIMESPEC_TEST_Values(timespec)
   MLB_TIMESPEC_TEST_Values(MLB::Utility::TimeSpec)
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void TEST_ExplicitConversions()
{
	using namespace MLB::Utility;

	TimeSpec now;

	std::cout << "Now         : " << now << '\n';
	std::cout << "Seconds     : " << TimeSpec::FromSeconds(now.ToSeconds())           << '\n';
	std::cout << "Milliseconds: " << TimeSpec::FromMilliseconds(now.ToMilliseconds()) << '\n';
	std::cout << "Microseconds: " << TimeSpec::FromMicroseconds(now.ToMicroseconds()) << '\n';
	std::cout << "Nanoseconds : " << TimeSpec::FromNanoseconds(now.ToNanoseconds())   << '\n';
}
// ////////////////////////////////////////////////////////////////////////////

} // Anonymous namespace

// ////////////////////////////////////////////////////////////////////////////
int main()
{
   int return_code = EXIT_SUCCESS;

   try {
      TEST_RunRelOpTests();
		TEST_ExplicitConversions();
	}
   catch (const std::exception &except) {
      return_code = EXIT_FAILURE;
      std::cerr << "\n\nRegression test error: " << except.what() << std::endl;
   }

   return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

#endif // #ifdef TEST_MAIN

